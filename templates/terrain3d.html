<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain 3D - Coordonnées en temps réel</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        // Injection sûre de l'id du terrain depuis Flask
        var terrain_id = {{ terrain_id|tojson|safe }};
    </script>
    <script>
      window.terrain_id = {{ terrain_id|tojson|safe }};
    </script>
    <style>
        body {
            background: linear-gradient(120deg, #e3f2fd 60%, #f8f8f8 100%);
            font-family: 'Segoe UI', 'Arial', sans-serif;
            margin: 0;
            min-height: 100vh;
        }
        header {
            width: 100vw;
            background: linear-gradient(90deg, #1976d2 60%, #64b5f6 100%);
            box-shadow: 0 4px 24px #1976d233;
            padding: 0 0 18px 0;
            border-radius: 0 0 32px 32px;
        }
        h1 {
            text-align: center;
            color: #fff;
            font-size: 2.5em;
            margin: 0;
            padding: 32px 0 10px 0;
            letter-spacing: 1.5px;
            text-shadow: 0 2px 12px #1976d288;
        }
        .config-bar {
            margin: 0 auto 18px auto;
            text-align: center;
            display: flex;
            gap: 18px;
            justify-content: center;
            width: fit-content;
        }
        .config-bar button {
            background: linear-gradient(90deg, #1976d2 60%, #64b5f6 100%);
            color: #fff;
            border: none;
            border-radius: 10px;
            padding: 12px 28px;
            font-size: 1.12em;
            font-weight: 600;
            box-shadow: 0 2px 12px #1976d233;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s, box-shadow 0.2s;
        }
        .config-bar button:hover {
            background: linear-gradient(90deg, #1565c0 60%, #4fc3f7 100%);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 18px #1976d244;
        }
        #terrain3d {
            width: 1000px;
            height: 650px;
            display: block;
            border: 3px solid #1a237e;
            background: linear-gradient(135deg, #e0ffe0 60%, #b3e5fc 100%);
            margin: 30px auto 20px auto;
            box-shadow: 0 12px 40px #1976d244, 0 1.5px 0 #fff8 inset;
            border-radius: 22px;
            transition: box-shadow 0.3s, border 0.2s;
        }
        #terrain3d:focus, #terrain3d:hover {
            box-shadow: 0 0 0 6px #1976d2aa, 0 12px 40px #1976d244;
            outline: none;
            border: 3px solid #64b5f6;
        }
        .footer-signature {
            text-align: center;
            color: #1976d2;
            font-size: 1.08em;
            margin: 40px 0 18px 0;
            opacity: 0.7;
            letter-spacing: 0.5px;
        }
        @media (max-width: 1100px) {
            #terrain3d {
                width: 98vw;
                height: 54vw;
                min-height: 350px;
                max-width: 99vw;
            }
        }
        @media (max-width: 700px) {
            h1 {
                font-size: 1.5em;
                padding: 18px 0 6px 0;
            }
            #terrain3d {
                height: 48vw;
                min-height: 180px;
            }
            .config-bar {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Terrain 3D - Coordonnées en temps réel (Terrain {{ terrain_id }})</h1>
        <div class="config-bar">
            <button onclick="setView('reset')">Reset</button>
            <button id="fullscreen-btn">Plein écran</button>
            <button onclick="setView('top')">Vue du dessus</button>
            <button onclick="setView('side')">Vue latérale</button>
            <button onclick="setView('perspective')">Perspective</button>
        </div>
        <div id="score-bar" style="margin: 18px auto 0 auto; text-align: center; font-size: 1.3em; font-weight: bold; color: #1976d2; background: #e3f2fd; border-radius: 12px; padding: 8px 24px; display: inline-block; box-shadow: 0 2px 8px #1976d222;">
            <span id="blue-team-name">Bleu</span>
            <span style="margin: 0 18px; color: #888;">-</span>
            <span id="blue-score">0</span>
            <span style="margin: 0 18px; color: #888;">-</span>
            <span id="green-score">0</span>
            <span style="margin: 0 18px; color: #888;">-</span>
            <span id="green-team-name">Vert</span>
        </div>
    </header>
    <canvas id="terrain3d" tabindex="0"></canvas>
    <footer>
        <p class="footer-signature">Développé par Samuel Legrand - 2025</p>
    </footer>
    <!-- Injection sûre de l'id du terrain depuis Flask, avant tout JS -->
    <script type="text/javascript">
      // Flask will inject terrain_id here; if not running via Flask, set a default for testing
      var terrain_id = {{ terrain_id|tojson|safe }};
      if (typeof terrain_id === "undefined" || terrain_id === null) {
        terrain_id = 1;
      }
    </script>
    <script>
    // --- Constantes physiques du terrain et objets (en mètres) ---
    const field_length = 1.84;
    const field_width = 1.23;
    const goal_width = 0.6;
    const goal_virtual_height = 0.1;
    const border_size = 0.3;
    const robot_radius = 0.088;
    const robot_height = 0.076;
    const ball_radius = 0.021;
    const ball_height = 0.021;
    // --- Initialisation Babylon.js ---
    const canvas = document.getElementById("terrain3d");
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    // Racine pour rotation globale
    const root = new BABYLON.TransformNode("root", scene);
    // Camera orbitale
    const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI/2, Math.PI/2.5, 2.5, new BABYLON.Vector3(0,0,0), scene);
    camera.attachControl(canvas, true);
    // Lumière
    const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    // Sol (terrain) avec plus de subdivisions pour une meilleure interpolation
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width:field_length, height:field_width, subdivisions: 8}, scene);
    ground.position.y = 0;
    ground.parent = root;
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    // Texture d'herbe libre de droits (Three.js CDN, hotlink autorisé)
    const grassTex = new BABYLON.Texture("https://threejs.org/examples/textures/terrain/grasslight-big.jpg", scene);
    groundMat.diffuseTexture = grassTex;
    groundMat.diffuseTexture.uScale = 4;
    groundMat.diffuseTexture.vScale = 4;
    groundMat.specularColor = new BABYLON.Color3(0, 0, 0); // Suppression du reflet
    groundMat.emissiveColor = new BABYLON.Color3(0, 0, 0); // Pas d'émissif
    groundMat.alpha = 1.0;
    groundMat.roughness = 1.0;
    groundMat.useGlossinessFromSpecularMapAlpha = false;
    groundMat.freeze();
    ground.material = groundMat;
    // Ajout d'un contour blanc épais autour du terrain
    const outline = BABYLON.MeshBuilder.CreateLines("fieldOutline", {
        points: [
            new BABYLON.Vector3(-field_length/2, 0.015, -field_width/2),
            new BABYLON.Vector3(-field_length/2, 0.015, field_width/2),
            new BABYLON.Vector3(field_length/2, 0.015, field_width/2),
            new BABYLON.Vector3(field_length/2, 0.015, -field_width/2),
            new BABYLON.Vector3(-field_length/2, 0.015, -field_width/2)
        ],
        updatable: false
    }, scene);
    outline.color = new BABYLON.Color3(1,1,1);
    outline.enableEdgesRendering();
    outline.edgesWidth = 8;
    outline.parent = root;
    // Ajout de lignes blanches pour marquage terrain
    function createFieldLines() {
        // Rectangle principal
        BABYLON.MeshBuilder.CreateLines("fieldRect", {
            points: [
                new BABYLON.Vector3(-field_length/2, 0.016, -field_width/2),
                new BABYLON.Vector3(-field_length/2, 0.016, field_width/2),
                new BABYLON.Vector3(field_length/2, 0.016, field_width/2),
                new BABYLON.Vector3(field_length/2, 0.016, -field_width/2),
                new BABYLON.Vector3(-field_length/2, 0.016, -field_width/2)
            ],
            updatable: false
        }, scene).color = new BABYLON.Color3(1,1,1);
        // Ligne médiane
        BABYLON.MeshBuilder.CreateLines("midLine", {
            points: [
                new BABYLON.Vector3(0, 0.016, -field_width/2),
                new BABYLON.Vector3(0, 0.016, field_width/2)
            ]
        }, scene).color = new BABYLON.Color3(1,1,1);
        // Cercle central
        BABYLON.MeshBuilder.CreateDashedLines("centerCircle", {
            points: Array.from({length: 64}, (_, i) => {
                const angle = (i/64)*2*Math.PI;
                return new BABYLON.Vector3(Math.cos(angle)*0.18, 0.016, Math.sin(angle)*0.18);
            }),
            dashSize: 0.04, gapSize: 0.02, updatable: false
        }, scene).color = new BABYLON.Color3(1,1,1);
        // Surfaces de réparation
        const areaW = 0.9, areaL = -0.3;
        // Zone gauche (côté -field_length/2)
        BABYLON.MeshBuilder.CreateLines("area1", {
            points: [
                new BABYLON.Vector3(-field_length/2, 0.016, -areaW/2),
                new BABYLON.Vector3(-field_length/2-areaL, 0.016, -areaW/2),
                new BABYLON.Vector3(-field_length/2-areaL, 0.016, areaW/2),
                new BABYLON.Vector3(-field_length/2, 0.016, areaW/2)
            ],
            updatable: false
        }, scene).color = new BABYLON.Color3(1,1,1);
        // Zone droite (côté +field_length/2)
        BABYLON.MeshBuilder.CreateLines("area2", {
            points: [
                new BABYLON.Vector3(field_length/2, 0.016, -areaW/2),
                new BABYLON.Vector3(field_length/2+areaL, 0.016, -areaW/2),
                new BABYLON.Vector3(field_length/2+areaL, 0.016, areaW/2),
                new BABYLON.Vector3(field_length/2, 0.016, areaW/2)
            ],
            updatable: false
        }, scene).color = new BABYLON.Color3(1,1,1);
    }
    createFieldLines();
    // Bordure (carpet)
    const border = BABYLON.MeshBuilder.CreateGround("border", {width:field_length+2*border_size, height:field_width+2*border_size, subdivisions: 2}, scene);
    border.position.y = -0.002;
    border.parent = root;
    const borderMat = new BABYLON.StandardMaterial("borderMat", scene);
    borderMat.diffuseColor = new BABYLON.Color3(0.11, 0.36, 0.11);
    borderMat.specularColor = new BABYLON.Color3(0.1,0.2,0.1);
    borderMat.alpha = 0.98;
    border.material = borderMat;
    // Amélioration de la lumière
    light.intensity = 1.22;
    light.diffuse = new BABYLON.Color3(1,1,1);
    light.specular = new BABYLON.Color3(0.5,0.5,0.5);
    // Ajout d'une lumière directionnelle douce pour relief
    const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5,-1,-0.5), scene);
    dirLight.intensity = 0.32;
    dirLight.diffuse = new BABYLON.Color3(1,1,1);
    dirLight.specular = new BABYLON.Color3(0.7,0.7,0.7);
    // --- Buts ---
    function createGoal(x, color) {
        const y1 = -goal_width/2;
        const y2 = goal_width/2;
        // Poteaux
        const post1 = BABYLON.MeshBuilder.CreateBox("post1", {height:goal_virtual_height, width:0.02, depth:0.02}, scene);
        post1.position = new BABYLON.Vector3(x, goal_virtual_height/2, y1);
        post1.material = new BABYLON.StandardMaterial("postMat1", scene);
        post1.material.diffuseColor = color;
        post1.parent = root;
        const post2 = BABYLON.MeshBuilder.CreateBox("post2", {height:goal_virtual_height, width:0.02, depth:0.02}, scene);
        post2.position = new BABYLON.Vector3(x, goal_virtual_height/2, y2);
        post2.material = new BABYLON.StandardMaterial("postMat2", scene);
        post2.material.diffuseColor = color;
        post2.parent = root;
        // Barre transversale
        const bar = BABYLON.MeshBuilder.CreateBox("bar", {height:0.02, width:0.02, depth:goal_width}, scene);
        bar.position = new BABYLON.Vector3(x, goal_virtual_height, 0);
        bar.material = new BABYLON.StandardMaterial("barMat", scene);
        bar.material.diffuseColor = color;
        bar.parent = root;
    }
    // Inversion des couleurs : but bleu à gauche, but vert à droite
    createGoal(field_length/2, new BABYLON.Color3(0,1,0)); // But vert à droite
    createGoal(-field_length/2, new BABYLON.Color3(0,0,1)); // But bleu à gauche

    // --- Points fixes ---
    const fixedPoints = {};
    const pointCoords = {
        point1: [0.45, 0.3],
        point2: [-0.45, 0.3],
        point3: [-0.45, -0.3],
        point4: [0.45, -0.3]
    };
    for (const [name, [x, y]] of Object.entries(pointCoords)) {
        const sphere = BABYLON.MeshBuilder.CreateSphere(name, {diameter:0.04}, scene);
        sphere.position = new BABYLON.Vector3(x, 0.025, y);
        sphere.material = new BABYLON.StandardMaterial(name+"Mat", scene);
        sphere.material.diffuseColor = new BABYLON.Color3(1, 0.7, 0.1);
        sphere.parent = root;
        fixedPoints[name] = sphere;
    }
        function createGoal(x, color) {
        const y1 = -goal_width/2;
        const y2 = goal_width/2;
        // Poteaux
        const post1 = BABYLON.MeshBuilder.CreateBox("post1", {height:goal_virtual_height, width:0.02, depth:0.02}, scene);
        post1.position = new BABYLON.Vector3(x, goal_virtual_height/2, y1);
        post1.material = new BABYLON.StandardMaterial("postMat1", scene);
        post1.material.diffuseColor = color;
        post1.parent = root;
        const post2 = BABYLON.MeshBuilder.CreateBox("post2", {height:goal_virtual_height, width:0.02, depth:0.02}, scene);
        post2.position = new BABYLON.Vector3(x, goal_virtual_height/2, y2);
        post2.material = new BABYLON.StandardMaterial("postMat2", scene);
        post2.material.diffuseColor = color;
        post2.parent = root;
        // Barre transversale
        const bar = BABYLON.MeshBuilder.CreateBox("bar", {height:0.02, width:0.02, depth:goal_width}, scene);
        bar.position = new BABYLON.Vector3(x, goal_virtual_height, 0);
        bar.material = new BABYLON.StandardMaterial("barMat", scene);
        bar.material.diffuseColor = color;
        bar.parent = root;
    }
    // Inversion des couleurs : but bleu à gauche, but vert à droite
    createGoal(field_length/2, new BABYLON.Color3(0,1,0)); // But vert à droite
    createGoal(-field_length/2, new BABYLON.Color3(0,0,1));
    // --- Robots ---
    function createFlatFrontRobot(name, color, scene, number) {
        // Corps principal (cylindre)
        const body = BABYLON.MeshBuilder.CreateCylinder(name + "_body", {
            diameter: robot_radius*2 ,
            height: robot_height,
            tessellation: 48
        }, scene);
        // Plat avant (boîte fine)
        const flat = BABYLON.MeshBuilder.CreateBox(name + "_flat", {
            width: robot_radius * 2,
            height: robot_height * 1.01,
            depth: robot_radius * 1

        }, scene);
        flat.position.z = robot_radius * 0.5;
        // Même couleur
        const mat = new BABYLON.StandardMaterial(name + "mat", scene);
        mat.diffuseColor = color;
        body.material = mat;
        flat.material = mat;
        // Numéro (plan avec texture dynamique)
        const dynTex = new BABYLON.DynamicTexture(name + "_numtex", {width:128, height:128}, scene, false);
        dynTex.hasAlpha = true;
        dynTex.drawText(number.toString(), 64, 90, "bold 90px Arial", "#fff", "#222", true);
        const numMat = new BABYLON.StandardMaterial(name + "_nummat", scene);
        numMat.diffuseTexture = dynTex;
        numMat.emissiveColor = new BABYLON.Color3(1,1,1);
        numMat.specularColor = new BABYLON.Color3(0,0,0);
        numMat.backFaceCulling = false;
        const numPlane = BABYLON.MeshBuilder.CreatePlane(name + "_num", {
            width: robot_radius*1, height: robot_height*1.2
        }, scene);
        numPlane.material = numMat;
        numPlane.position.z = robot_radius * 1; // bien devant le plat
        numPlane.position.y = robot_height *0.55; // à mi-hauteur
        numPlane.rotation.x = Math.PI/2;
        // Grouper
        const robot = BABYLON.Mesh.MergeMeshes([body, flat, numPlane], true, false, undefined, false, true);
        robot.parent = root;
        return robot;
    }
    // Exemple : 4 robots
    const robot1 = createFlatFrontRobot("robot1", new BABYLON.Color3(0,0,1), scene, 1); 
    robot1.position = new BABYLON.Vector3(-0.3, 0, 0);
    const robot2 = createFlatFrontRobot("robot2", new BABYLON.Color3(0,0,1), scene, 2);
        
    robot2.position = new BABYLON.Vector3(0.3, 0, 0);
    const robot3 = createFlatFrontRobot("robot3", new BABYLON.Color3(0,1,0), scene, 1);
    robot3.position = new BABYLON.Vector3(0, 0, 0.3);
    const robot4 = createFlatFrontRobot("robot4", new BABYLON.Color3(0,1,0), scene, 2);
    robot4.position = new BABYLON.Vector3(0, 0, -0.3);

    // --- Balle ---
    const ball = BABYLON.MeshBuilder.CreateSphere("ball", {diameter:ball_radius*2}, scene);
    ball.position.y = ball_radius;
    ball.position.x = 0;
    ball.position.z = 0;
    ball.material = new BABYLON.StandardMaterial("ballmat", scene);
    ball.material.diffuseColor = new BABYLON.Color3(1,0,0);
    ball.parent = root;
    // --- Synchronisation Socket.IO ---
    const robots = [robot1, robot2, robot3, robot4];
    // Connexion Socket.IO
    const socket = io();
    // Rejoindre la room du terrain courant
    socket.emit('join_terrain', {terrain_id: terrain_id});
    socket.on('update_coordinates_' + terrain_id, function(data) {
        // Met à jour la scène avec les données reçues
        updateObjects(data);
        updateScoreBar(data);
    });
    function updateObjects(data) {
        // Correction dynamique selon la position x du robot
        // Si x < 0 : +90°, si x > 0 : -90°
        const robotsData = [data.blue1, data.blue2, data.green1, data.green2];
        const robotKeys = [0, 1, 2, 3];
        for (let i = 0; i < robotsData.length; i++) {
            if (!robotsData[i]) continue;
            const x = robotsData[i][0];
            const y = robotsData[i][1];
            const theta = robotsData[i][2];
            robots[robotKeys[i]].position = new BABYLON.Vector3(x, robot_height/2, y);
            if (typeof theta === 'number') {
                if (x < 0) {
                    robots[robotKeys[i]].rotation.y = -theta + Math.PI/2;
                } else {
                    robots[robotKeys[i]].rotation.y = -theta + Math.PI/2;
                }
            }
        }
        if (data.ball) {
            ball.position = new BABYLON.Vector3(data.ball[0], ball_radius, data.ball[1]);
        }
    }
    function updateScoreBar(data) {
        if (data.blue_team_name) {
            document.getElementById('blue-team-name').textContent = data.blue_team_name;
        }
        if (data.green_team_name) {
            document.getElementById('green-team-name').textContent = data.green_team_name;
        }
        if (typeof data.blue_score !== 'undefined') {
            document.getElementById('blue-score').textContent = data.blue_score;
        }
        if (typeof data.green_score !== 'undefined') {
            document.getElementById('green-score').textContent = data.green_score;
        }
    }
    // --- Affichage du score et des équipes sur le terrain 3D ---
    // Charger Babylon.js GUI si ce n'est pas déjà fait
    if (typeof BABYLON.GUI === 'undefined') {
        var guiScript = document.createElement('script');
        guiScript.src = 'https://cdn.babylonjs.com/gui/babylon.gui.min.js';
        guiScript.onload = function() {
            createScorePanel();
        };
        document.head.appendChild(guiScript);
    } else {
        createScorePanel();
    }
    function createScorePanel() {
        const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        const scorePanel = new BABYLON.GUI.Rectangle();
        scorePanel.height = "60px";
        scorePanel.cornerRadius = 16;
        scorePanel.color = "#1976d2";
        scorePanel.thickness = 3;
        scorePanel.background = "#e3f2fd";
        scorePanel.top = "30px";
        scorePanel.left = "0px";
        scorePanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        scorePanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        scorePanel.width = 1; // largeur relative (100%) pour permettre l'agrandissement
        scorePanel.paddingLeft = "30px";
        scorePanel.paddingRight = "30px";
        advancedTexture.addControl(scorePanel);
        // Utilisation d'un StackPanel horizontal pour éviter la superposition
        const stackPanel = new BABYLON.GUI.StackPanel();
        stackPanel.isVertical = false;
        stackPanel.height = "100%";
        stackPanel.width = 1;
        stackPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        stackPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        scorePanel.addControl(stackPanel);
        // Noms et scores
        const blueTeamText = new BABYLON.GUI.TextBlock();
        blueTeamText.text = "Bleu";
        blueTeamText.color = "#1976d2";
        blueTeamText.fontSize = 28;
        blueTeamText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        blueTeamText.resizeToFit = true;
        blueTeamText.textWrapping = true;
        blueTeamText.paddingRight = "16px";
        stackPanel.addControl(blueTeamText);
        const blueScoreText = new BABYLON.GUI.TextBlock();
        blueScoreText.text = "0";
        blueScoreText.color = "#1976d2";
        blueScoreText.fontSize = 32;
        blueScoreText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        blueScoreText.paddingRight = "24px";
        stackPanel.addControl(blueScoreText);
        const dashText = new BABYLON.GUI.TextBlock();
        dashText.text = "-";
        dashText.color = "#888";
        dashText.fontSize = 28;
        dashText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        dashText.paddingRight = "24px";
        dashText.paddingLeft = "24px";
        stackPanel.addControl(dashText);
        const greenScoreText = new BABYLON.GUI.TextBlock();
        greenScoreText.text = "0";
        greenScoreText.color = "#388e3c";
        greenScoreText.fontSize = 32;
        greenScoreText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        greenScoreText.paddingRight = "16px";
        stackPanel.addControl(greenScoreText);
        const greenTeamText = new BABYLON.GUI.TextBlock();
        greenTeamText.text = "Vert";
        greenTeamText.color = "#388e3c";
        greenTeamText.fontSize = 28;
        greenTeamText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        greenTeamText.resizeToFit = true;
        greenTeamText.textWrapping = true;
        stackPanel.addControl(greenTeamText);
        // Fonction de mise à jour du panneau
        function updateScorePanel(data) {
            if (data.blue_team_name) blueTeamText.text = data.blue_team_name;
            if (data.green_team_name) greenTeamText.text = data.green_team_name;
            if (typeof data.blue_score !== 'undefined') blueScoreText.text = data.blue_score;
            if (typeof data.green_score !== 'undefined') greenScoreText.text = data.green_score;
        }
        // Appeler updateScorePanel à chaque réception de données
        socket.on('update_coordinates_' + terrain_id, function(data) {
            updateScorePanel(data);
        });
    }
    // --- Fonctions de vue caméra ---
    function setView(view) {
        if (view === 'reset') {
            camera.setPosition(new BABYLON.Vector3(0, 2.5, 0));
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.alpha = Math.PI/2;
            camera.beta = Math.PI/2.5;
            camera.radius = 2.5;
        } else if (view === 'top') {
            camera.setPosition(new BABYLON.Vector3(0, 2.5, 0));
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.alpha = Math.PI/2;
            camera.beta = 0.01 + 0.0001; // vue du dessus
            camera.radius = 2.5;
        } else if (view === 'side') {
            camera.setPosition(new BABYLON.Vector3(0, 0.5, -2.5));
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.alpha = 0;
            camera.beta = Math.PI/2;
            camera.radius = 2.5;
        } else if (view === 'perspective') {
            camera.setPosition(new BABYLON.Vector3(1.5, 1.2, -1.5));
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.alpha = Math.PI/4;
            camera.beta = Math.PI/3;
            camera.radius = 2.5;
        }
    }
    // --- Animation et update ---
    engine.runRenderLoop(function () {
        scene.render();
    });
    window.addEventListener("resize", function () {
        engine.resize();
    });
    </script>
</body>
</html>
